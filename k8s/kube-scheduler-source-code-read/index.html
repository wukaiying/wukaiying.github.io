<!DOCTYPE html>
<html lang="en-us">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
  <title>K8S Scheduler 源码分析 - Kaiying</title>
  <meta property="og:title" content="K8S Scheduler 源码分析 - Kaiying" />
  <meta name="twitter:title" content="K8S Scheduler 源码分析 - Kaiying" />
  <meta name="description" content="k8s scheduler 源码分析">
  <meta property="og:description" content="k8s scheduler 源码分析">
  <meta name="twitter:description" content="k8s scheduler 源码分析">
  <meta name="author" content="kaiying"/>
  <meta property="og:site_name" content="Kaiying" />
  <meta property="og:url" content="https://wukaiying.github.io/k8s/kube-scheduler-source-code-read/" />
  <meta property="og:type" content="article" />
  <meta name="twitter:card" content="summary" />
  <meta name="generator" content="Hugo 0.61.0" />

  <link rel="stylesheet" href="/css/style.css" media="all" />
  <link rel="stylesheet" href="/css/syntax.css" media="all" />
  <link rel="stylesheet" href="/css/custom.css" media="all" />

  <script src="/js/script.js"></script>
  <script src="/js/custom.js"></script>
  <script defer src="/js/fontawesome.js"></script>
</head>

<body>

<header class="site-header">
  <nav class="site-navi">
    <h1 class="site-title"><a href="/">Kaiying</a></h1>
    <ul class="site-navi-items">
      <li class="site-navi-item-categories"><a href="/categories/" title="Categories">Categories</a></li>
      <li class="site-navi-item-tags"><a href="/tags/" title="Tags">Tags</a></li>
      <li class="site-navi-item-archives"><a href="/archives/" title="Archives">Archives</a></li>
      <li class="site-navi-item-about"><a href="/about/" title="About">About</a></li>
    </ul>
  </nav>
</header>
<hr class="site-header-bottom">

  <div class="main" role="main">
    <article class="article">
      
      
      <h1 class="article-title">K8S Scheduler 源码分析</h1>
      
      <hr class="article-title-bottom">
      <ul class="article-meta">
        <li class="article-meta-date"><time>April 22, 2020</time></li>
        <li class="article-meta-categories">
          <a href="/categories/k8s/">
            <i class="fas fa-folder"></i>
            k8s
          </a>&nbsp;
        </li>
      </ul>
      
<aside class="toc">
  <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#heading">版本环境</a></li>
        <li><a href="#heading-1">前言</a></li>
        <li><a href="#heading-2">入口</a></li>
        <li><a href="#heading-3">总结</a></li>
        <li><a href="#heading-4">后续</a></li>
        <li><a href="#heading-5">参考</a></li>
      </ul>
    </li>
  </ul>
</nav>
</aside>
      <h3 id="heading">版本环境</h3>
<ul>
<li>
<p>kubernetes版本：kubernetes:v1.16.0</p>
</li>
<li>
<p>go环境：go version go1.13.4 darwin/amd64</p>
</li>
</ul>
<h3 id="heading-1">前言</h3>
<p>kube-scheduler 是master节点中重要的组件之一，它同watch接口监听api server中需要调度的pod，然后通过其预选，优选算法来确定pod需要被调度到哪个节点上去。</p>
<p>看一下官方对scheduler 调度流程的描述：<a href="https://github.com/kubernetes/community/blob/master/contributors/devel/sig-scheduling/scheduler.md">The Kubernetes Scheduler</a></p>
<p>主要步骤如下：</p>
<ul>
<li>首先通过预选阶段过滤掉不合适的节点，例如根据podSpec中对系统资源的需求，会计算出所有节点剩余的资源是否可以满足pod需求，如果不满足则该节点会被抛弃。</li>
<li>其次通过预选阶段的节点，会再次进行优选。比如在满足pod资源需求的基础上，会优选出当前负载最小节点，保证每个集群节点资源被均衡使用。</li>
<li>最后选择打分最高的节点作为目标节点，如果得分相同则会随机选择一个，进行调度。</li>
</ul>
<pre><code>For given pod:

    +---------------------------------------------+
    |               Schedulable nodes:            |
    |                                             |
    | +--------+    +--------+      +--------+    |
    | | node 1 |    | node 2 |      | node 3 |    |
    | +--------+    +--------+      +--------+    |
    |                                             |
    +-------------------+-------------------------+
                        |
                        |
                        v
    +-------------------+-------------------------+

    Pred. filters: node 3 doesn't have enough resource

    +-------------------+-------------------------+
                        |
                        |
                        v
    +-------------------+-------------------------+
    |             remaining nodes:                |
    |   +--------+                 +--------+     |
    |   | node 1 |                 | node 2 |     |
    |   +--------+                 +--------+     |
    |                                             |
    +-------------------+-------------------------+
                        |
                        |
                        v
    +-------------------+-------------------------+

    Priority function:    node 1: p=2
                          node 2: p=5

    +-------------------+-------------------------+
                        |
                        |
                        v
            select max{node priority} = node 2
</code></pre><h3 id="heading-2">入口</h3>
<p>scheduler使用cobra创建命令行客户端，进入<code>NewSchedulerCommand</code></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">//cmd/kube-scheduler/scheduler.go:32
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">rand</span>.<span style="color:#a6e22e">Seed</span>(<span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Now</span>().<span style="color:#a6e22e">UnixNano</span>())
	<span style="color:#a6e22e">command</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">app</span>.<span style="color:#a6e22e">NewSchedulerCommand</span>()
	<span style="color:#a6e22e">pflag</span>.<span style="color:#a6e22e">CommandLine</span>.<span style="color:#a6e22e">SetNormalizeFunc</span>(<span style="color:#a6e22e">cliflag</span>.<span style="color:#a6e22e">WordSepNormalizeFunc</span>)
	<span style="color:#75715e">// utilflag.InitFlags()
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">logs</span>.<span style="color:#a6e22e">InitLogs</span>()
	<span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">logs</span>.<span style="color:#a6e22e">FlushLogs</span>()
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">command</span>.<span style="color:#a6e22e">Execute</span>(); <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
		<span style="color:#a6e22e">os</span>.<span style="color:#a6e22e">Exit</span>(<span style="color:#ae81ff">1</span>)
	}
}
</code></pre></div><h4 id="newschedulercommand">NewSchedulerCommand</h4>
<p>我们可以看到该方法通过接受用户传递进来的scheduler参数来通过<code>runCommand</code>方法来启动scheduler，下面进入<code>runCommand</code></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">//cmd/kube-scheduler/app/server.go:69
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">NewSchedulerCommand</span>(<span style="color:#a6e22e">registryOptions</span> <span style="color:#f92672">...</span><span style="color:#a6e22e">Option</span>) <span style="color:#f92672">*</span><span style="color:#a6e22e">cobra</span>.<span style="color:#a6e22e">Command</span> {
	<span style="color:#a6e22e">opts</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">options</span>.<span style="color:#a6e22e">NewOptions</span>()
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
		<span style="color:#a6e22e">klog</span>.<span style="color:#a6e22e">Fatalf</span>(<span style="color:#e6db74">&#34;unable to initialize command options: %v&#34;</span>, <span style="color:#a6e22e">err</span>)
	}

	<span style="color:#a6e22e">cmd</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">cobra</span>.<span style="color:#a6e22e">Command</span>{
		<span style="color:#a6e22e">Use</span>: <span style="color:#e6db74">&#34;kube-scheduler&#34;</span>,
		<span style="color:#a6e22e">Run</span>: <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">cmd</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">cobra</span>.<span style="color:#a6e22e">Command</span>, <span style="color:#a6e22e">args</span> []<span style="color:#66d9ef">string</span>) {
			<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">runCommand</span>(<span style="color:#a6e22e">cmd</span>, <span style="color:#a6e22e">args</span>, <span style="color:#a6e22e">opts</span>, <span style="color:#a6e22e">registryOptions</span><span style="color:#f92672">...</span>); <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
				<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Fprintf</span>(<span style="color:#a6e22e">os</span>.<span style="color:#a6e22e">Stderr</span>, <span style="color:#e6db74">&#34;%v\n&#34;</span>, <span style="color:#a6e22e">err</span>)
				<span style="color:#a6e22e">os</span>.<span style="color:#a6e22e">Exit</span>(<span style="color:#ae81ff">1</span>)
			}
		},
	}
	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">cmd</span>
}
</code></pre></div><h4 id="runcommand">runCommand</h4>
<p>runCommand方法主要作用是校验scheduler 配置参数，生成scheduler配置文件，并通过Run方法来启动scheduler。主要流程如下：</p>
<ul>
<li>校验通过cobra传递进来的配置参数</li>
<li>生成scheduler 配置项</li>
<li>不全得到完整的scheduler启动参数结构体</li>
<li>将完整的启动参数结构体传入Run函数，然后启动scheduler</li>
</ul>
<p>接下来我们进入Run方法来看，scheduler具体如何启动。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">//cmd/kube-scheduler/app/server.go:116
</span><span style="color:#75715e"></span><span style="color:#75715e">// runCommand runs the scheduler.
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">runCommand</span>(<span style="color:#a6e22e">cmd</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">cobra</span>.<span style="color:#a6e22e">Command</span>, <span style="color:#a6e22e">args</span> []<span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">opts</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">options</span>.<span style="color:#a6e22e">Options</span>, <span style="color:#a6e22e">registryOptions</span> <span style="color:#f92672">...</span><span style="color:#a6e22e">Option</span>) <span style="color:#66d9ef">error</span> {
	
    <span style="color:#75715e">//校验通过cobra传递进来的配置参数
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">verflag</span>.<span style="color:#a6e22e">PrintAndExitIfRequested</span>()
	<span style="color:#a6e22e">utilflag</span>.<span style="color:#a6e22e">PrintFlags</span>(<span style="color:#a6e22e">cmd</span>.<span style="color:#a6e22e">Flags</span>())

	<span style="color:#66d9ef">if</span> len(<span style="color:#a6e22e">args</span>) <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span> {
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Fprint</span>(<span style="color:#a6e22e">os</span>.<span style="color:#a6e22e">Stderr</span>, <span style="color:#e6db74">&#34;arguments are not supported\n&#34;</span>)
	}

	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">errs</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">opts</span>.<span style="color:#a6e22e">Validate</span>(); len(<span style="color:#a6e22e">errs</span>) &gt; <span style="color:#ae81ff">0</span> {
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Fprintf</span>(<span style="color:#a6e22e">os</span>.<span style="color:#a6e22e">Stderr</span>, <span style="color:#e6db74">&#34;%v\n&#34;</span>, <span style="color:#a6e22e">utilerrors</span>.<span style="color:#a6e22e">NewAggregate</span>(<span style="color:#a6e22e">errs</span>))
		<span style="color:#a6e22e">os</span>.<span style="color:#a6e22e">Exit</span>(<span style="color:#ae81ff">1</span>)
	}

	<span style="color:#66d9ef">if</span> len(<span style="color:#a6e22e">opts</span>.<span style="color:#a6e22e">WriteConfigTo</span>) &gt; <span style="color:#ae81ff">0</span> {
		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">options</span>.<span style="color:#a6e22e">WriteConfigFile</span>(<span style="color:#a6e22e">opts</span>.<span style="color:#a6e22e">WriteConfigTo</span>, <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">opts</span>.<span style="color:#a6e22e">ComponentConfig</span>); <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
			<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Fprintf</span>(<span style="color:#a6e22e">os</span>.<span style="color:#a6e22e">Stderr</span>, <span style="color:#e6db74">&#34;%v\n&#34;</span>, <span style="color:#a6e22e">err</span>)
			<span style="color:#a6e22e">os</span>.<span style="color:#a6e22e">Exit</span>(<span style="color:#ae81ff">1</span>)
		}
		<span style="color:#a6e22e">klog</span>.<span style="color:#a6e22e">Infof</span>(<span style="color:#e6db74">&#34;Wrote configuration to: %s\n&#34;</span>, <span style="color:#a6e22e">opts</span>.<span style="color:#a6e22e">WriteConfigTo</span>)
	}
    <span style="color:#75715e">//生成scheduler 配置项
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">c</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">opts</span>.<span style="color:#a6e22e">Config</span>()
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Fprintf</span>(<span style="color:#a6e22e">os</span>.<span style="color:#a6e22e">Stderr</span>, <span style="color:#e6db74">&#34;%v\n&#34;</span>, <span style="color:#a6e22e">err</span>)
		<span style="color:#a6e22e">os</span>.<span style="color:#a6e22e">Exit</span>(<span style="color:#ae81ff">1</span>)
	}

	<span style="color:#a6e22e">stopCh</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">struct</span>{})
	<span style="color:#75715e">// Get the completed config
</span><span style="color:#75715e"></span>    <span style="color:#75715e">//得到完整的scheduler启动参数结构体
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">cc</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">Complete</span>()

	<span style="color:#75715e">// To help debugging, immediately log version
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">klog</span>.<span style="color:#a6e22e">Infof</span>(<span style="color:#e6db74">&#34;Version: %+v&#34;</span>, <span style="color:#a6e22e">version</span>.<span style="color:#a6e22e">Get</span>())

	<span style="color:#75715e">// Apply algorithms based on feature gates.
</span><span style="color:#75715e"></span>	<span style="color:#75715e">// TODO: make configurable?
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">algorithmprovider</span>.<span style="color:#a6e22e">ApplyFeatureGates</span>()

	<span style="color:#75715e">// Configz registration.
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">cz</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">configz</span>.<span style="color:#a6e22e">New</span>(<span style="color:#e6db74">&#34;componentconfig&#34;</span>); <span style="color:#a6e22e">err</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
		<span style="color:#a6e22e">cz</span>.<span style="color:#a6e22e">Set</span>(<span style="color:#a6e22e">cc</span>.<span style="color:#a6e22e">ComponentConfig</span>)
	} <span style="color:#66d9ef">else</span> {
		<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Errorf</span>(<span style="color:#e6db74">&#34;unable to register configz: %s&#34;</span>, <span style="color:#a6e22e">err</span>)
	}

    <span style="color:#75715e">//将完整的启动参数结构体传入Run函数，然后启动scheduler
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">Run</span>(<span style="color:#a6e22e">cc</span>, <span style="color:#a6e22e">stopCh</span>, <span style="color:#a6e22e">registryOptions</span><span style="color:#f92672">...</span>)
}
</code></pre></div><h4 id="run-scheduler">Run 启动scheduler</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">//cmd/kube-scheduler/app/server.go:165
</span><span style="color:#75715e"></span><span style="color:#75715e">// Run executes the scheduler based on the given configuration. It only return on error or when stopCh is closed.
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">Run</span>(<span style="color:#a6e22e">cc</span> <span style="color:#a6e22e">schedulerserverconfig</span>.<span style="color:#a6e22e">CompletedConfig</span>, <span style="color:#a6e22e">stopCh</span> <span style="color:#f92672">&lt;-</span><span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">struct</span>{}, <span style="color:#a6e22e">registryOptions</span> <span style="color:#f92672">...</span><span style="color:#a6e22e">Option</span>) <span style="color:#66d9ef">error</span> {
	<span style="color:#75715e">// To help debugging, immediately log version
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">klog</span>.<span style="color:#a6e22e">V</span>(<span style="color:#ae81ff">1</span>).<span style="color:#a6e22e">Infof</span>(<span style="color:#e6db74">&#34;Starting Kubernetes Scheduler version %+v&#34;</span>, <span style="color:#a6e22e">version</span>.<span style="color:#a6e22e">Get</span>())

	<span style="color:#a6e22e">registry</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">framework</span>.<span style="color:#a6e22e">NewRegistry</span>()
	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">option</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">registryOptions</span> {
		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">option</span>(<span style="color:#a6e22e">registry</span>); <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
			<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">err</span>
		}
	}

	<span style="color:#75715e">// 初始化 event clients，记录调度事件
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">cc</span>.<span style="color:#a6e22e">Client</span>.<span style="color:#a6e22e">Discovery</span>().<span style="color:#a6e22e">ServerResourcesForGroupVersion</span>(<span style="color:#a6e22e">eventsv1beta1</span>.<span style="color:#a6e22e">SchemeGroupVersion</span>.<span style="color:#a6e22e">String</span>()); <span style="color:#a6e22e">err</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
		<span style="color:#a6e22e">cc</span>.<span style="color:#a6e22e">Broadcaster</span> = <span style="color:#a6e22e">events</span>.<span style="color:#a6e22e">NewBroadcaster</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">events</span>.<span style="color:#a6e22e">EventSinkImpl</span>{<span style="color:#a6e22e">Interface</span>: <span style="color:#a6e22e">cc</span>.<span style="color:#a6e22e">EventClient</span>.<span style="color:#a6e22e">Events</span>(<span style="color:#e6db74">&#34;&#34;</span>)})
		<span style="color:#a6e22e">cc</span>.<span style="color:#a6e22e">Recorder</span> = <span style="color:#a6e22e">cc</span>.<span style="color:#a6e22e">Broadcaster</span>.<span style="color:#a6e22e">NewRecorder</span>(<span style="color:#a6e22e">scheme</span>.<span style="color:#a6e22e">Scheme</span>, <span style="color:#a6e22e">cc</span>.<span style="color:#a6e22e">ComponentConfig</span>.<span style="color:#a6e22e">SchedulerName</span>)
	} <span style="color:#66d9ef">else</span> {
		<span style="color:#a6e22e">recorder</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">cc</span>.<span style="color:#a6e22e">CoreBroadcaster</span>.<span style="color:#a6e22e">NewRecorder</span>(<span style="color:#a6e22e">scheme</span>.<span style="color:#a6e22e">Scheme</span>, <span style="color:#a6e22e">v1</span>.<span style="color:#a6e22e">EventSource</span>{<span style="color:#a6e22e">Component</span>: <span style="color:#a6e22e">cc</span>.<span style="color:#a6e22e">ComponentConfig</span>.<span style="color:#a6e22e">SchedulerName</span>})
		<span style="color:#a6e22e">cc</span>.<span style="color:#a6e22e">Recorder</span> = <span style="color:#a6e22e">record</span>.<span style="color:#a6e22e">NewEventRecorderAdapter</span>(<span style="color:#a6e22e">recorder</span>)
	}

	<span style="color:#75715e">//新建scheduler
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">sched</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">scheduler</span>.<span style="color:#a6e22e">New</span>(<span style="color:#a6e22e">cc</span>.<span style="color:#a6e22e">Client</span>,
		<span style="color:#a6e22e">cc</span>.<span style="color:#a6e22e">InformerFactory</span>.<span style="color:#a6e22e">Core</span>().<span style="color:#a6e22e">V1</span>().<span style="color:#a6e22e">Nodes</span>(),
		<span style="color:#a6e22e">cc</span>.<span style="color:#a6e22e">PodInformer</span>,
		<span style="color:#a6e22e">cc</span>.<span style="color:#a6e22e">InformerFactory</span>.<span style="color:#a6e22e">Core</span>().<span style="color:#a6e22e">V1</span>().<span style="color:#a6e22e">PersistentVolumes</span>(),
		<span style="color:#a6e22e">cc</span>.<span style="color:#a6e22e">InformerFactory</span>.<span style="color:#a6e22e">Core</span>().<span style="color:#a6e22e">V1</span>().<span style="color:#a6e22e">PersistentVolumeClaims</span>(),
		<span style="color:#a6e22e">cc</span>.<span style="color:#a6e22e">InformerFactory</span>.<span style="color:#a6e22e">Core</span>().<span style="color:#a6e22e">V1</span>().<span style="color:#a6e22e">ReplicationControllers</span>(),
		<span style="color:#a6e22e">cc</span>.<span style="color:#a6e22e">InformerFactory</span>.<span style="color:#a6e22e">Apps</span>().<span style="color:#a6e22e">V1</span>().<span style="color:#a6e22e">ReplicaSets</span>(),
		<span style="color:#a6e22e">cc</span>.<span style="color:#a6e22e">InformerFactory</span>.<span style="color:#a6e22e">Apps</span>().<span style="color:#a6e22e">V1</span>().<span style="color:#a6e22e">StatefulSets</span>(),
		<span style="color:#a6e22e">cc</span>.<span style="color:#a6e22e">InformerFactory</span>.<span style="color:#a6e22e">Core</span>().<span style="color:#a6e22e">V1</span>().<span style="color:#a6e22e">Services</span>(),
		<span style="color:#a6e22e">cc</span>.<span style="color:#a6e22e">InformerFactory</span>.<span style="color:#a6e22e">Policy</span>().<span style="color:#a6e22e">V1beta1</span>().<span style="color:#a6e22e">PodDisruptionBudgets</span>(),
		<span style="color:#a6e22e">cc</span>.<span style="color:#a6e22e">InformerFactory</span>.<span style="color:#a6e22e">Storage</span>().<span style="color:#a6e22e">V1</span>().<span style="color:#a6e22e">StorageClasses</span>(),
		<span style="color:#a6e22e">cc</span>.<span style="color:#a6e22e">InformerFactory</span>.<span style="color:#a6e22e">Storage</span>().<span style="color:#a6e22e">V1beta1</span>().<span style="color:#a6e22e">CSINodes</span>(),
		<span style="color:#a6e22e">cc</span>.<span style="color:#a6e22e">Recorder</span>,
		<span style="color:#a6e22e">cc</span>.<span style="color:#a6e22e">ComponentConfig</span>.<span style="color:#a6e22e">AlgorithmSource</span>,
		<span style="color:#a6e22e">stopCh</span>,
		<span style="color:#a6e22e">registry</span>,
		<span style="color:#a6e22e">cc</span>.<span style="color:#a6e22e">ComponentConfig</span>.<span style="color:#a6e22e">Plugins</span>,
		<span style="color:#a6e22e">cc</span>.<span style="color:#a6e22e">ComponentConfig</span>.<span style="color:#a6e22e">PluginConfig</span>,
		<span style="color:#a6e22e">scheduler</span>.<span style="color:#a6e22e">WithName</span>(<span style="color:#a6e22e">cc</span>.<span style="color:#a6e22e">ComponentConfig</span>.<span style="color:#a6e22e">SchedulerName</span>),
		<span style="color:#a6e22e">scheduler</span>.<span style="color:#a6e22e">WithHardPodAffinitySymmetricWeight</span>(<span style="color:#a6e22e">cc</span>.<span style="color:#a6e22e">ComponentConfig</span>.<span style="color:#a6e22e">HardPodAffinitySymmetricWeight</span>),
		<span style="color:#a6e22e">scheduler</span>.<span style="color:#a6e22e">WithPreemptionDisabled</span>(<span style="color:#a6e22e">cc</span>.<span style="color:#a6e22e">ComponentConfig</span>.<span style="color:#a6e22e">DisablePreemption</span>),
		<span style="color:#a6e22e">scheduler</span>.<span style="color:#a6e22e">WithPercentageOfNodesToScore</span>(<span style="color:#a6e22e">cc</span>.<span style="color:#a6e22e">ComponentConfig</span>.<span style="color:#a6e22e">PercentageOfNodesToScore</span>),
		<span style="color:#a6e22e">scheduler</span>.<span style="color:#a6e22e">WithBindTimeoutSeconds</span>(<span style="color:#f92672">*</span><span style="color:#a6e22e">cc</span>.<span style="color:#a6e22e">ComponentConfig</span>.<span style="color:#a6e22e">BindTimeoutSeconds</span>))
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
		<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">err</span>
	}

	<span style="color:#75715e">// 启动事件广播
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">cc</span>.<span style="color:#a6e22e">Broadcaster</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">cc</span>.<span style="color:#a6e22e">EventClient</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
		<span style="color:#a6e22e">cc</span>.<span style="color:#a6e22e">Broadcaster</span>.<span style="color:#a6e22e">StartRecordingToSink</span>(<span style="color:#a6e22e">stopCh</span>)
	}
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">cc</span>.<span style="color:#a6e22e">CoreBroadcaster</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">cc</span>.<span style="color:#a6e22e">CoreEventClient</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
		<span style="color:#a6e22e">cc</span>.<span style="color:#a6e22e">CoreBroadcaster</span>.<span style="color:#a6e22e">StartRecordingToSink</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">corev1</span>.<span style="color:#a6e22e">EventSinkImpl</span>{<span style="color:#a6e22e">Interface</span>: <span style="color:#a6e22e">cc</span>.<span style="color:#a6e22e">CoreEventClient</span>.<span style="color:#a6e22e">Events</span>(<span style="color:#e6db74">&#34;&#34;</span>)})
	}

	<span style="color:#75715e">// 启动podinformer，监听pod事件
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">go</span> <span style="color:#a6e22e">cc</span>.<span style="color:#a6e22e">PodInformer</span>.<span style="color:#a6e22e">Informer</span>().<span style="color:#a6e22e">Run</span>(<span style="color:#a6e22e">stopCh</span>)
	<span style="color:#a6e22e">cc</span>.<span style="color:#a6e22e">InformerFactory</span>.<span style="color:#a6e22e">Start</span>(<span style="color:#a6e22e">stopCh</span>)

	<span style="color:#75715e">// 调度之前等待informer初始化cache完成
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">cc</span>.<span style="color:#a6e22e">InformerFactory</span>.<span style="color:#a6e22e">WaitForCacheSync</span>(<span style="color:#a6e22e">stopCh</span>)

	<span style="color:#75715e">// Prepare a reusable runCommand function.
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">run</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">ctx</span> <span style="color:#a6e22e">context</span>.<span style="color:#a6e22e">Context</span>) {
		<span style="color:#a6e22e">sched</span>.<span style="color:#a6e22e">Run</span>()
		<span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">ctx</span>.<span style="color:#a6e22e">Done</span>()
	}

	<span style="color:#a6e22e">ctx</span>, <span style="color:#a6e22e">cancel</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">context</span>.<span style="color:#a6e22e">WithCancel</span>(<span style="color:#a6e22e">context</span>.<span style="color:#a6e22e">TODO</span>()) <span style="color:#75715e">// TODO once Run() accepts a context, it should be used here
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">cancel</span>()

	<span style="color:#66d9ef">go</span> <span style="color:#66d9ef">func</span>() {
		<span style="color:#66d9ef">select</span> {
		<span style="color:#66d9ef">case</span> <span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">stopCh</span>:
			<span style="color:#a6e22e">cancel</span>()
		<span style="color:#66d9ef">case</span> <span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">ctx</span>.<span style="color:#a6e22e">Done</span>():
		}
	}()

	<span style="color:#75715e">// 选举出leader
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">cc</span>.<span style="color:#a6e22e">LeaderElection</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
		<span style="color:#a6e22e">cc</span>.<span style="color:#a6e22e">LeaderElection</span>.<span style="color:#a6e22e">Callbacks</span> = <span style="color:#a6e22e">leaderelection</span>.<span style="color:#a6e22e">LeaderCallbacks</span>{
			<span style="color:#a6e22e">OnStartedLeading</span>: <span style="color:#a6e22e">run</span>,
			<span style="color:#a6e22e">OnStoppedLeading</span>: <span style="color:#66d9ef">func</span>() {
				<span style="color:#a6e22e">klog</span>.<span style="color:#a6e22e">Fatalf</span>(<span style="color:#e6db74">&#34;leaderelection lost&#34;</span>)
			},
		}
		<span style="color:#a6e22e">leaderElector</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">leaderelection</span>.<span style="color:#a6e22e">NewLeaderElector</span>(<span style="color:#f92672">*</span><span style="color:#a6e22e">cc</span>.<span style="color:#a6e22e">LeaderElection</span>)
		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
			<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Errorf</span>(<span style="color:#e6db74">&#34;couldn&#39;t create leader elector: %v&#34;</span>, <span style="color:#a6e22e">err</span>)
		}

		<span style="color:#a6e22e">leaderElector</span>.<span style="color:#a6e22e">Run</span>(<span style="color:#a6e22e">ctx</span>)

		<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Errorf</span>(<span style="color:#e6db74">&#34;lost lease&#34;</span>)
	}

	<span style="color:#75715e">// 选举完成后执行sched.Run()
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">run</span>(<span style="color:#a6e22e">ctx</span>)
	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Errorf</span>(<span style="color:#e6db74">&#34;finished without leader elect&#34;</span>)
}
</code></pre></div><p>接下来我们进入<code>sched.Run()</code>方法来看，它启动一个循环逻辑，来执行<code>sched.scheduleOne</code></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">//pkg/scheduler/scheduler.go:315
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">sched</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Scheduler</span>) <span style="color:#a6e22e">Run</span>() {
	<span style="color:#66d9ef">if</span> !<span style="color:#a6e22e">sched</span>.<span style="color:#a6e22e">WaitForCacheSync</span>() {
		<span style="color:#66d9ef">return</span>
	}
	<span style="color:#66d9ef">go</span> <span style="color:#a6e22e">wait</span>.<span style="color:#a6e22e">Until</span>(<span style="color:#a6e22e">sched</span>.<span style="color:#a6e22e">scheduleOne</span>, <span style="color:#ae81ff">0</span>, <span style="color:#a6e22e">sched</span>.<span style="color:#a6e22e">StopEverything</span>)
}
</code></pre></div><p>现在我们来看下<code>sched.scheduleOne</code>的实现，通过goroutine 启动的scheduleOne，每个协程一次只会为一个pod执行调度计算。
主要流程如下：</p>
<ul>
<li>从待调度队列中取出一个pod，这块背后是由SchedulingQueue该模块实现，暂不进行深入分析</li>
<li>如果pod被标记为待删除，则不进行调度</li>
<li>加载调度策略，通过sched.schedule来对pod进行调度，如果调度成功会得到一个node节点名称（此时已经经过预选和优选完成）</li>
<li>如果调度失败，查看返回的错误中，该pod是否启动了抢占策略，如果没有则什么也不做，pod重新入队，重新调度。</li>
<li>执行绑定操作，也就是将pod.Spec.NodeName设置为选出来的node</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">//pkg/scheduler/scheduler.go:517
</span><span style="color:#75715e"></span><span style="color:#75715e">// scheduleOne does the entire scheduling workflow for a single pod.  It is serialized on the scheduling algorithm&#39;s host fitting.
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">sched</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Scheduler</span>) <span style="color:#a6e22e">scheduleOne</span>() {
	<span style="color:#a6e22e">fwk</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">sched</span>.<span style="color:#a6e22e">Framework</span>

    <span style="color:#75715e">//从待调度队列中取出一个pod，这块背后是由SchedulingQueue该模块实现，暂不进行深入分析
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">pod</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">sched</span>.<span style="color:#a6e22e">NextPod</span>()
	<span style="color:#75715e">// pod could be nil when schedulerQueue is closed
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">pod</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
		<span style="color:#66d9ef">return</span>
	}
    <span style="color:#75715e">//如果pod被标记为待删除，则不进行调度
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">pod</span>.<span style="color:#a6e22e">DeletionTimestamp</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
		<span style="color:#a6e22e">sched</span>.<span style="color:#a6e22e">Recorder</span>.<span style="color:#a6e22e">Eventf</span>(<span style="color:#a6e22e">pod</span>, <span style="color:#66d9ef">nil</span>, <span style="color:#a6e22e">v1</span>.<span style="color:#a6e22e">EventTypeWarning</span>, <span style="color:#e6db74">&#34;FailedScheduling&#34;</span>, <span style="color:#e6db74">&#34;Scheduling&#34;</span>, <span style="color:#e6db74">&#34;skip schedule deleting pod: %v/%v&#34;</span>, <span style="color:#a6e22e">pod</span>.<span style="color:#a6e22e">Namespace</span>, <span style="color:#a6e22e">pod</span>.<span style="color:#a6e22e">Name</span>)
		<span style="color:#a6e22e">klog</span>.<span style="color:#a6e22e">V</span>(<span style="color:#ae81ff">3</span>).<span style="color:#a6e22e">Infof</span>(<span style="color:#e6db74">&#34;Skip schedule deleting pod: %v/%v&#34;</span>, <span style="color:#a6e22e">pod</span>.<span style="color:#a6e22e">Namespace</span>, <span style="color:#a6e22e">pod</span>.<span style="color:#a6e22e">Name</span>)
		<span style="color:#66d9ef">return</span>
	}

	<span style="color:#a6e22e">klog</span>.<span style="color:#a6e22e">V</span>(<span style="color:#ae81ff">3</span>).<span style="color:#a6e22e">Infof</span>(<span style="color:#e6db74">&#34;Attempting to schedule pod: %v/%v&#34;</span>, <span style="color:#a6e22e">pod</span>.<span style="color:#a6e22e">Namespace</span>, <span style="color:#a6e22e">pod</span>.<span style="color:#a6e22e">Name</span>)

	<span style="color:#75715e">//加载调度策略，通过sched.schedule来对pod进行调度
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">start</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Now</span>()
	<span style="color:#a6e22e">pluginContext</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">framework</span>.<span style="color:#a6e22e">NewPluginContext</span>()

    <span style="color:#75715e">//此时如果err为空的话，scheduleResult中已经得到了目标node，如果err不为空则进行抢占调度
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">scheduleResult</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">sched</span>.<span style="color:#a6e22e">schedule</span>(<span style="color:#a6e22e">pod</span>, <span style="color:#a6e22e">pluginContext</span>)
    
    <span style="color:#75715e">//如果调度失败，查看返回的错误中，该pod是否启动了抢占策略，如果没有则什么也不做，pod重新入队，重新调度。
</span><span style="color:#75715e"></span>    <span style="color:#75715e">//如果启动了抢占策略(这里启动了抢占调度，对应于yaml文件中是为pod绑定了PriorityClass这种资源文件)，提供了一种抢占策略，可以挤掉优先级不高pod，抢先进行调度。
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">fitError</span>, <span style="color:#a6e22e">ok</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">err</span>.(<span style="color:#f92672">*</span><span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">FitError</span>); <span style="color:#a6e22e">ok</span> {
			<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">sched</span>.<span style="color:#a6e22e">DisablePreemption</span> {
				<span style="color:#a6e22e">klog</span>.<span style="color:#a6e22e">V</span>(<span style="color:#ae81ff">3</span>).<span style="color:#a6e22e">Infof</span>(<span style="color:#e6db74">&#34;Pod priority feature is not enabled or preemption is disabled by scheduler configuration.&#34;</span> <span style="color:#f92672">+</span>
					<span style="color:#e6db74">&#34; No preemption is performed.&#34;</span>)
			} <span style="color:#66d9ef">else</span> {
                <span style="color:#75715e">//执行抢占，并通过过滤算法选择合适的node
</span><span style="color:#75715e"></span>				<span style="color:#a6e22e">preemptionStartTime</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Now</span>()
				<span style="color:#a6e22e">sched</span>.<span style="color:#a6e22e">preempt</span>(<span style="color:#a6e22e">pluginContext</span>, <span style="color:#a6e22e">fwk</span>, <span style="color:#a6e22e">pod</span>, <span style="color:#a6e22e">fitError</span>)
			}
			<span style="color:#a6e22e">metrics</span>.<span style="color:#a6e22e">PodScheduleFailures</span>.<span style="color:#a6e22e">Inc</span>()
		} <span style="color:#66d9ef">else</span> {
			<span style="color:#a6e22e">klog</span>.<span style="color:#a6e22e">Errorf</span>(<span style="color:#e6db74">&#34;error selecting node for pod: %v&#34;</span>, <span style="color:#a6e22e">err</span>)
			<span style="color:#a6e22e">metrics</span>.<span style="color:#a6e22e">PodScheduleErrors</span>.<span style="color:#a6e22e">Inc</span>()
		}
		<span style="color:#66d9ef">return</span>
	}
	
	<span style="color:#a6e22e">assumedPod</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">pod</span>.<span style="color:#a6e22e">DeepCopy</span>()

	<span style="color:#75715e">//执行绑定操作，也就是将pod.Spec.NodeName设置为选出来的node
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">err</span> = <span style="color:#a6e22e">sched</span>.<span style="color:#a6e22e">assume</span>(<span style="color:#a6e22e">assumedPod</span>, <span style="color:#a6e22e">scheduleResult</span>.<span style="color:#a6e22e">SuggestedHost</span>)
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
		<span style="color:#a6e22e">klog</span>.<span style="color:#a6e22e">Errorf</span>(<span style="color:#e6db74">&#34;error assuming pod: %v&#34;</span>, <span style="color:#a6e22e">err</span>)
		<span style="color:#a6e22e">metrics</span>.<span style="color:#a6e22e">PodScheduleErrors</span>.<span style="color:#a6e22e">Inc</span>()
		<span style="color:#75715e">// trigger un-reserve plugins to clean up state associated with the reserved Pod
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">fwk</span>.<span style="color:#a6e22e">RunUnreservePlugins</span>(<span style="color:#a6e22e">pluginContext</span>, <span style="color:#a6e22e">assumedPod</span>, <span style="color:#a6e22e">scheduleResult</span>.<span style="color:#a6e22e">SuggestedHost</span>)
		<span style="color:#66d9ef">return</span>
	}
}
</code></pre></div><p>这里有必要分析下<code>scheduleResult, err := sched.schedule(pod, pluginContext)</code>，当err不为空时，说明没有合适的node进行调度，如果用户给pod配置了高调度优先级，则会触发pod抢占调度逻辑，抢占调度的具体应用场景及源码逻辑如下，</p>
<p>首先对应于yaml文件，我们可以这样提高pod的调度优先级</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#75715e"># Example PriorityClass</span>
apiVersion: scheduling.k8s.io/v1
kind: PriorityClass
metadata:
  name: high-priority
value: <span style="color:#ae81ff">1000000</span>
globalDefault: <span style="color:#66d9ef">false</span>
description: <span style="color:#e6db74">&#34;This priority class should be used for XYZ service pods only.&#34;</span>

<span style="color:#75715e"># Example Pod spec</span>
apiVersion: v1
kind: Pod
metadata:
  name: nginx
  labels:
    env: test
spec:
  containers:
  - name: nginx
    image: nginx
    imagePullPolicy: IfNotPresent
  priorityClassName: high-priority
</code></pre></div><p>来看下抢占核心逻辑<code>sched.preempt(pluginContext, fwk, pod, fitError)</code>的具体实现：
主要逻辑如下：</p>
<ul>
<li>通过默认注册的抢占算法，计算得出最终被执行抢占调度的node、node上需要驱逐的pod等信息</li>
<li>可以进行抢占调度的node不为空时，给PriorityQueue队列中添加新元素(调度的pod和目标node的信息)</li>
<li>接下来给抢占调度的pod加上指定的NominatedNodeName，也就是设置pod.Status.NominatedNodeName=nodeName</li>
<li>删除node上低优先级的pod</li>
<li>当抢占执行完成，或者没有合适的node是，都会执行删除pod.Status.NominatedNodeName=nodeName，以免影响下次抢占调度</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">sched</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Scheduler</span>) <span style="color:#a6e22e">preempt</span>(<span style="color:#a6e22e">pluginContext</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">framework</span>.<span style="color:#a6e22e">PluginContext</span>, <span style="color:#a6e22e">fwk</span> <span style="color:#a6e22e">framework</span>.<span style="color:#a6e22e">Framework</span>, <span style="color:#a6e22e">preemptor</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">v1</span>.<span style="color:#a6e22e">Pod</span>, <span style="color:#a6e22e">scheduleErr</span> <span style="color:#66d9ef">error</span>) (<span style="color:#66d9ef">string</span>, <span style="color:#66d9ef">error</span>) {
	<span style="color:#a6e22e">preemptor</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">sched</span>.<span style="color:#a6e22e">PodPreemptor</span>.<span style="color:#a6e22e">GetUpdatedPod</span>(<span style="color:#a6e22e">preemptor</span>)
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
		<span style="color:#a6e22e">klog</span>.<span style="color:#a6e22e">Errorf</span>(<span style="color:#e6db74">&#34;Error getting the updated preemptor pod object: %v&#34;</span>, <span style="color:#a6e22e">err</span>)
		<span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;&#34;</span>, <span style="color:#a6e22e">err</span>
	}
    <span style="color:#75715e">//  // 通过默认注册的抢占算法，计算得出最终被执行抢占调度的node、node上需要驱逐的pod等信息
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">node</span>, <span style="color:#a6e22e">victims</span>, <span style="color:#a6e22e">nominatedPodsToClear</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">sched</span>.<span style="color:#a6e22e">Algorithm</span>.<span style="color:#a6e22e">Preempt</span>(<span style="color:#a6e22e">pluginContext</span>, <span style="color:#a6e22e">preemptor</span>, <span style="color:#a6e22e">scheduleErr</span>)
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
		<span style="color:#a6e22e">klog</span>.<span style="color:#a6e22e">Errorf</span>(<span style="color:#e6db74">&#34;Error preempting victims to make room for %v/%v: %v&#34;</span>, <span style="color:#a6e22e">preemptor</span>.<span style="color:#a6e22e">Namespace</span>, <span style="color:#a6e22e">preemptor</span>.<span style="color:#a6e22e">Name</span>, <span style="color:#a6e22e">err</span>)
		<span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;&#34;</span>, <span style="color:#a6e22e">err</span>
	}
	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">nodeName</span> = <span style="color:#e6db74">&#34;&#34;</span>
    <span style="color:#75715e">//可以进行抢占调度的node不为空时
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">node</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
		<span style="color:#a6e22e">nodeName</span> = <span style="color:#a6e22e">node</span>.<span style="color:#a6e22e">Name</span>
		<span style="color:#75715e">// Update the scheduling queue with the nominated pod information. Without
</span><span style="color:#75715e"></span>		<span style="color:#75715e">// this, there would be a race condition between the next scheduling cycle
</span><span style="color:#75715e"></span>		<span style="color:#75715e">// and the time the scheduler receives a Pod Update for the nominated pod.
</span><span style="color:#75715e"></span>		<span style="color:#75715e">// 给SchedulingQueue队列中添加抢占调度的pod和目标node的信息
</span><span style="color:#75715e"></span>        <span style="color:#a6e22e">sched</span>.<span style="color:#a6e22e">SchedulingQueue</span>.<span style="color:#a6e22e">UpdateNominatedPodForNode</span>(<span style="color:#a6e22e">preemptor</span>, <span style="color:#a6e22e">nodeName</span>)

		<span style="color:#75715e">// Make a call to update nominated node name of the pod on the API server.
</span><span style="color:#75715e"></span>        <span style="color:#75715e">//给抢占调度的pod加上指定的NominatedNodeName，也就是设置pod.Status.NominatedNodeName=nodeName
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">err</span> = <span style="color:#a6e22e">sched</span>.<span style="color:#a6e22e">PodPreemptor</span>.<span style="color:#a6e22e">SetNominatedNodeName</span>(<span style="color:#a6e22e">preemptor</span>, <span style="color:#a6e22e">nodeName</span>)
		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
			<span style="color:#a6e22e">klog</span>.<span style="color:#a6e22e">Errorf</span>(<span style="color:#e6db74">&#34;Error in preemption process. Cannot set &#39;NominatedPod&#39; on pod %v/%v: %v&#34;</span>, <span style="color:#a6e22e">preemptor</span>.<span style="color:#a6e22e">Namespace</span>, <span style="color:#a6e22e">preemptor</span>.<span style="color:#a6e22e">Name</span>, <span style="color:#a6e22e">err</span>)
			<span style="color:#a6e22e">sched</span>.<span style="color:#a6e22e">SchedulingQueue</span>.<span style="color:#a6e22e">DeleteNominatedPodIfExists</span>(<span style="color:#a6e22e">preemptor</span>)
			<span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;&#34;</span>, <span style="color:#a6e22e">err</span>
		}

        <span style="color:#75715e">//删除nodeName上低优先级的pod
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">victim</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">victims</span> {
			<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">sched</span>.<span style="color:#a6e22e">PodPreemptor</span>.<span style="color:#a6e22e">DeletePod</span>(<span style="color:#a6e22e">victim</span>); <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
				<span style="color:#a6e22e">klog</span>.<span style="color:#a6e22e">Errorf</span>(<span style="color:#e6db74">&#34;Error preempting pod %v/%v: %v&#34;</span>, <span style="color:#a6e22e">victim</span>.<span style="color:#a6e22e">Namespace</span>, <span style="color:#a6e22e">victim</span>.<span style="color:#a6e22e">Name</span>, <span style="color:#a6e22e">err</span>)
				<span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;&#34;</span>, <span style="color:#a6e22e">err</span>
			}
			<span style="color:#75715e">// If the victim is a WaitingPod, send a reject message to the PermitPlugin
</span><span style="color:#75715e"></span>			<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">waitingPod</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">fwk</span>.<span style="color:#a6e22e">GetWaitingPod</span>(<span style="color:#a6e22e">victim</span>.<span style="color:#a6e22e">UID</span>); <span style="color:#a6e22e">waitingPod</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
				<span style="color:#a6e22e">waitingPod</span>.<span style="color:#a6e22e">Reject</span>(<span style="color:#e6db74">&#34;preempted&#34;</span>)
			}
			<span style="color:#a6e22e">sched</span>.<span style="color:#a6e22e">Recorder</span>.<span style="color:#a6e22e">Eventf</span>(<span style="color:#a6e22e">victim</span>, <span style="color:#a6e22e">preemptor</span>, <span style="color:#a6e22e">v1</span>.<span style="color:#a6e22e">EventTypeNormal</span>, <span style="color:#e6db74">&#34;Preempted&#34;</span>, <span style="color:#e6db74">&#34;Preempting&#34;</span>, <span style="color:#e6db74">&#34;Preempted by %v/%v on node %v&#34;</span>, <span style="color:#a6e22e">preemptor</span>.<span style="color:#a6e22e">Namespace</span>, <span style="color:#a6e22e">preemptor</span>.<span style="color:#a6e22e">Name</span>, <span style="color:#a6e22e">nodeName</span>)

		}
		<span style="color:#a6e22e">metrics</span>.<span style="color:#a6e22e">PreemptionVictims</span>.<span style="color:#a6e22e">Set</span>(float64(len(<span style="color:#a6e22e">victims</span>)))
	}
	<span style="color:#75715e">// Clearing nominated pods should happen outside of &#34;if node != nil&#34;. Node could
</span><span style="color:#75715e"></span>	<span style="color:#75715e">// be nil when a pod with nominated node name is eligible to preempt again,
</span><span style="color:#75715e"></span>	<span style="color:#75715e">// but preemption logic does not find any node for it. In that case Preempt()
</span><span style="color:#75715e"></span>	<span style="color:#75715e">// function of generic_scheduler.go returns the pod itself for removal of
</span><span style="color:#75715e"></span>	<span style="color:#75715e">// the &#39;NominatedPod&#39; field.
</span><span style="color:#75715e"></span>    <span style="color:#75715e">//这里有两种情况，当可以执行抢占的node不存在，则清除pod中的NominatedNodeName字段。
</span><span style="color:#75715e"></span>    <span style="color:#75715e">//抢占逻辑执行完成后，也需要执行清除pod中的NominatedNodeName字段。
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">p</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">nominatedPodsToClear</span> {
		<span style="color:#a6e22e">rErr</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">sched</span>.<span style="color:#a6e22e">PodPreemptor</span>.<span style="color:#a6e22e">RemoveNominatedNodeName</span>(<span style="color:#a6e22e">p</span>)
		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">rErr</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
			<span style="color:#a6e22e">klog</span>.<span style="color:#a6e22e">Errorf</span>(<span style="color:#e6db74">&#34;Cannot remove &#39;NominatedPod&#39; field of pod: %v&#34;</span>, <span style="color:#a6e22e">rErr</span>)
			<span style="color:#75715e">// We do not return as this error is not critical.
</span><span style="color:#75715e"></span>		}
	}
	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">nodeName</span>, <span style="color:#a6e22e">err</span>
}

</code></pre></div><p>如果<code>scheduleResult, err := sched.schedule(pod, pluginContext)</code>，err为空，则说明调度成功，不需要执行抢占，这里面就包含了调度器的预选，优选算法，我们详细分析下
进入schedule</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">//pkg/scheduler/scheduler.go:339
</span><span style="color:#75715e"></span><span style="color:#75715e">// schedule implements the scheduling algorithm and returns the suggested result(host,
</span><span style="color:#75715e"></span><span style="color:#75715e">// evaluated nodes number,feasible nodes number).
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">sched</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Scheduler</span>) <span style="color:#a6e22e">schedule</span>(<span style="color:#a6e22e">pod</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">v1</span>.<span style="color:#a6e22e">Pod</span>, <span style="color:#a6e22e">pluginContext</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">framework</span>.<span style="color:#a6e22e">PluginContext</span>) (<span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">ScheduleResult</span>, <span style="color:#66d9ef">error</span>) {
	<span style="color:#a6e22e">result</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">sched</span>.<span style="color:#a6e22e">Algorithm</span>.<span style="color:#a6e22e">Schedule</span>(<span style="color:#a6e22e">pod</span>, <span style="color:#a6e22e">pluginContext</span>)
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
		<span style="color:#a6e22e">pod</span> = <span style="color:#a6e22e">pod</span>.<span style="color:#a6e22e">DeepCopy</span>()
		<span style="color:#a6e22e">sched</span>.<span style="color:#a6e22e">recordSchedulingFailure</span>(<span style="color:#a6e22e">pod</span>, <span style="color:#a6e22e">err</span>, <span style="color:#a6e22e">v1</span>.<span style="color:#a6e22e">PodReasonUnschedulable</span>, <span style="color:#a6e22e">err</span>.<span style="color:#a6e22e">Error</span>())
		<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">core</span>.<span style="color:#a6e22e">ScheduleResult</span>{}, <span style="color:#a6e22e">err</span>
	}
	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">result</span>, <span style="color:#a6e22e">err</span>
}
</code></pre></div><p>发现<code>sched.Algorithm.Schedule</code>他是<code>ScheduleAlgorithm</code>接口的一个实现，里面包含四个方法，我们来看Schedule的具体实现</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">///pkg/scheduler/core/generic_scheduler.go:134
</span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">ScheduleAlgorithm</span> <span style="color:#66d9ef">interface</span> {
	<span style="color:#a6e22e">Schedule</span>(<span style="color:#f92672">*</span><span style="color:#a6e22e">v1</span>.<span style="color:#a6e22e">Pod</span>, <span style="color:#f92672">*</span><span style="color:#a6e22e">framework</span>.<span style="color:#a6e22e">PluginContext</span>) (<span style="color:#a6e22e">scheduleResult</span> <span style="color:#a6e22e">ScheduleResult</span>, <span style="color:#a6e22e">err</span> <span style="color:#66d9ef">error</span>)
	
	<span style="color:#a6e22e">Preempt</span>(<span style="color:#f92672">*</span><span style="color:#a6e22e">framework</span>.<span style="color:#a6e22e">PluginContext</span>, <span style="color:#f92672">*</span><span style="color:#a6e22e">v1</span>.<span style="color:#a6e22e">Pod</span>, <span style="color:#66d9ef">error</span>) (<span style="color:#a6e22e">selectedNode</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">v1</span>.<span style="color:#a6e22e">Node</span>, <span style="color:#a6e22e">preemptedPods</span> []<span style="color:#f92672">*</span><span style="color:#a6e22e">v1</span>.<span style="color:#a6e22e">Pod</span>, <span style="color:#a6e22e">cleanupNominatedPods</span> []<span style="color:#f92672">*</span><span style="color:#a6e22e">v1</span>.<span style="color:#a6e22e">Pod</span>, <span style="color:#a6e22e">err</span> <span style="color:#66d9ef">error</span>)
	
	<span style="color:#a6e22e">Predicates</span>() <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#a6e22e">predicates</span>.<span style="color:#a6e22e">FitPredicate</span>
	
	<span style="color:#a6e22e">Prioritizers</span>() []<span style="color:#a6e22e">priorities</span>.<span style="color:#a6e22e">PriorityConfig</span>
}
</code></pre></div><p>Schedule的具体实现中包含了预选优选两个阶段，主要步骤如下：</p>
<ul>
<li>pod做一些前置过滤</li>
<li>获取node数量 numNodes := g.cache.NodeTree().NumNodes()</li>
<li>执行预选算法，得到可用的node filteredNodes。filteredNodes = g.findNodesThatFit(pluginContext, pod)</li>
<li>如果预选完成没有合适的node,如果只有一个Node,则直接返回该node</li>
<li>在优选函数中传入pod信息，和符合条件的node信息，进行优选</li>
<li>通过打分机制选择出最合适的node，host= g.selectHost(priorityList)，完成scheduler调度</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">g</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">genericScheduler</span>) <span style="color:#a6e22e">Schedule</span>(<span style="color:#a6e22e">pod</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">v1</span>.<span style="color:#a6e22e">Pod</span>, <span style="color:#a6e22e">pluginContext</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">framework</span>.<span style="color:#a6e22e">PluginContext</span>) (<span style="color:#a6e22e">result</span> <span style="color:#a6e22e">ScheduleResult</span>, <span style="color:#a6e22e">err</span> <span style="color:#66d9ef">error</span>) {
	<span style="color:#a6e22e">trace</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">utiltrace</span>.<span style="color:#a6e22e">New</span>(<span style="color:#e6db74">&#34;Scheduling&#34;</span>, <span style="color:#a6e22e">utiltrace</span>.<span style="color:#a6e22e">Field</span>{<span style="color:#a6e22e">Key</span>: <span style="color:#e6db74">&#34;namespace&#34;</span>, <span style="color:#a6e22e">Value</span>: <span style="color:#a6e22e">pod</span>.<span style="color:#a6e22e">Namespace</span>}, <span style="color:#a6e22e">utiltrace</span>.<span style="color:#a6e22e">Field</span>{<span style="color:#a6e22e">Key</span>: <span style="color:#e6db74">&#34;name&#34;</span>, <span style="color:#a6e22e">Value</span>: <span style="color:#a6e22e">pod</span>.<span style="color:#a6e22e">Name</span>})
	<span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">trace</span>.<span style="color:#a6e22e">LogIfLong</span>(<span style="color:#ae81ff">100</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Millisecond</span>)

    <span style="color:#75715e">//下面这两部对pod做一些前置过滤
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">podPassesBasicChecks</span>(<span style="color:#a6e22e">pod</span>, <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">pvcLister</span>); <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
		<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">result</span>, <span style="color:#a6e22e">err</span>
	}
	<span style="color:#a6e22e">preFilterStatus</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">framework</span>.<span style="color:#a6e22e">RunPreFilterPlugins</span>(<span style="color:#a6e22e">pluginContext</span>, <span style="color:#a6e22e">pod</span>)
	<span style="color:#66d9ef">if</span> !<span style="color:#a6e22e">preFilterStatus</span>.<span style="color:#a6e22e">IsSuccess</span>() {
		<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">result</span>, <span style="color:#a6e22e">preFilterStatus</span>.<span style="color:#a6e22e">AsError</span>()
	}
    
    <span style="color:#75715e">//获取node数量
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">numNodes</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">cache</span>.<span style="color:#a6e22e">NodeTree</span>().<span style="color:#a6e22e">NumNodes</span>()
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">numNodes</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> {
		<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">result</span>, <span style="color:#a6e22e">ErrNoNodesAvailable</span>
	}
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">snapshot</span>(); <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
		<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">result</span>, <span style="color:#a6e22e">err</span>
	}

	<span style="color:#a6e22e">trace</span>.<span style="color:#a6e22e">Step</span>(<span style="color:#e6db74">&#34;Basic checks done&#34;</span>)
	<span style="color:#a6e22e">startPredicateEvalTime</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Now</span>()
    <span style="color:#75715e">//执行预选算法，得到可用的node filteredNodes。
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">filteredNodes</span>, <span style="color:#a6e22e">failedPredicateMap</span>, <span style="color:#a6e22e">filteredNodesStatuses</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">findNodesThatFit</span>(<span style="color:#a6e22e">pluginContext</span>, <span style="color:#a6e22e">pod</span>)
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
		<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">result</span>, <span style="color:#a6e22e">err</span>
	}
    <span style="color:#75715e">//如果预选完成没有合适的node,返回error
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> len(<span style="color:#a6e22e">filteredNodes</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> {
		<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">result</span>, <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">FitError</span>{
			<span style="color:#a6e22e">Pod</span>:                   <span style="color:#a6e22e">pod</span>,
			<span style="color:#a6e22e">NumAllNodes</span>:           <span style="color:#a6e22e">numNodes</span>,
			<span style="color:#a6e22e">FailedPredicates</span>:      <span style="color:#a6e22e">failedPredicateMap</span>,
			<span style="color:#a6e22e">FilteredNodesStatuses</span>: <span style="color:#a6e22e">filteredNodesStatuses</span>,
		}
	}
	<span style="color:#a6e22e">startPriorityEvalTime</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Now</span>()
	<span style="color:#75715e">// 如果只有一个Node,则直接返回该node
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> len(<span style="color:#a6e22e">filteredNodes</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span> {
		<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">ScheduleResult</span>{
			<span style="color:#a6e22e">SuggestedHost</span>:  <span style="color:#a6e22e">filteredNodes</span>[<span style="color:#ae81ff">0</span>].<span style="color:#a6e22e">Name</span>,
			<span style="color:#a6e22e">EvaluatedNodes</span>: <span style="color:#ae81ff">1</span> <span style="color:#f92672">+</span> len(<span style="color:#a6e22e">failedPredicateMap</span>),
			<span style="color:#a6e22e">FeasibleNodes</span>:  <span style="color:#ae81ff">1</span>,
		}, <span style="color:#66d9ef">nil</span>
	}

    <span style="color:#75715e">//根据pod的信息，执行优选算法
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">metaPrioritiesInterface</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">priorityMetaProducer</span>(<span style="color:#a6e22e">pod</span>, <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">nodeInfoSnapshot</span>.<span style="color:#a6e22e">NodeInfoMap</span>)
    <span style="color:#75715e">//在PrioritizeNodes中传入pod信息，和符合条件的node信息，进行优选
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">priorityList</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">PrioritizeNodes</span>(<span style="color:#a6e22e">pod</span>, <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">nodeInfoSnapshot</span>.<span style="color:#a6e22e">NodeInfoMap</span>, <span style="color:#a6e22e">metaPrioritiesInterface</span>, <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">prioritizers</span>, <span style="color:#a6e22e">filteredNodes</span>, <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">extenders</span>, <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">framework</span>, <span style="color:#a6e22e">pluginContext</span>)
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
		<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">result</span>, <span style="color:#a6e22e">err</span>
	}
	<span style="color:#a6e22e">trace</span>.<span style="color:#a6e22e">Step</span>(<span style="color:#e6db74">&#34;Prioritizing done&#34;</span>)

    <span style="color:#75715e">//通过打分机制选择出最合适的node
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">host</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">selectHost</span>(<span style="color:#a6e22e">priorityList</span>)
	<span style="color:#a6e22e">trace</span>.<span style="color:#a6e22e">Step</span>(<span style="color:#e6db74">&#34;Selecting host done&#34;</span>)
	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">ScheduleResult</span>{
		<span style="color:#a6e22e">SuggestedHost</span>:  <span style="color:#a6e22e">host</span>,
		<span style="color:#a6e22e">EvaluatedNodes</span>: len(<span style="color:#a6e22e">filteredNodes</span>) <span style="color:#f92672">+</span> len(<span style="color:#a6e22e">failedPredicateMap</span>),
		<span style="color:#a6e22e">FeasibleNodes</span>:  len(<span style="color:#a6e22e">filteredNodes</span>),
	}, <span style="color:#a6e22e">err</span>
}
</code></pre></div><p>最后，kube-scheduler在执行预选和优选过程中默认提供的调度算法，位置如下：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">// pkg/scheduler/algorithmprovider/defaults/defaults.go
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">defaultPredicates</span>() <span style="color:#a6e22e">sets</span>.<span style="color:#a6e22e">String</span> {
    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">sets</span>.<span style="color:#a6e22e">NewString</span>(
        <span style="color:#a6e22e">predicates</span>.<span style="color:#a6e22e">NoVolumeZoneConflictPred</span>,
        <span style="color:#a6e22e">predicates</span>.<span style="color:#a6e22e">MaxEBSVolumeCountPred</span>,
        <span style="color:#a6e22e">predicates</span>.<span style="color:#a6e22e">MaxGCEPDVolumeCountPred</span>,
        <span style="color:#a6e22e">predicates</span>.<span style="color:#a6e22e">MaxAzureDiskVolumeCountPred</span>,
        <span style="color:#a6e22e">predicates</span>.<span style="color:#a6e22e">MaxCSIVolumeCountPred</span>,
        <span style="color:#a6e22e">predicates</span>.<span style="color:#a6e22e">MatchInterPodAffinityPred</span>,
        <span style="color:#a6e22e">predicates</span>.<span style="color:#a6e22e">NoDiskConflictPred</span>,
        <span style="color:#a6e22e">predicates</span>.<span style="color:#a6e22e">GeneralPred</span>,
        <span style="color:#a6e22e">predicates</span>.<span style="color:#a6e22e">CheckNodeMemoryPressurePred</span>,
        <span style="color:#a6e22e">predicates</span>.<span style="color:#a6e22e">CheckNodeDiskPressurePred</span>,
        <span style="color:#a6e22e">predicates</span>.<span style="color:#a6e22e">CheckNodePIDPressurePred</span>,
        <span style="color:#a6e22e">predicates</span>.<span style="color:#a6e22e">CheckNodeConditionPred</span>,
        <span style="color:#a6e22e">predicates</span>.<span style="color:#a6e22e">PodToleratesNodeTaintsPred</span>,
        <span style="color:#a6e22e">predicates</span>.<span style="color:#a6e22e">CheckVolumeBindingPred</span>,
    )
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">defaultPriorities</span>() <span style="color:#a6e22e">sets</span>.<span style="color:#a6e22e">String</span> {
    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">sets</span>.<span style="color:#a6e22e">NewString</span>(
        <span style="color:#a6e22e">priorities</span>.<span style="color:#a6e22e">SelectorSpreadPriority</span>,
        <span style="color:#a6e22e">priorities</span>.<span style="color:#a6e22e">InterPodAffinityPriority</span>,
        <span style="color:#a6e22e">priorities</span>.<span style="color:#a6e22e">LeastRequestedPriority</span>,
        <span style="color:#a6e22e">priorities</span>.<span style="color:#a6e22e">BalancedResourceAllocation</span>,
        <span style="color:#a6e22e">priorities</span>.<span style="color:#a6e22e">NodePreferAvoidPodsPriority</span>,
        <span style="color:#a6e22e">priorities</span>.<span style="color:#a6e22e">NodeAffinityPriority</span>,
        <span style="color:#a6e22e">priorities</span>.<span style="color:#a6e22e">TaintTolerationPriority</span>,
        <span style="color:#a6e22e">priorities</span>.<span style="color:#a6e22e">ImageLocalityPriority</span>,
    )
}
</code></pre></div><p>这里我将主要的策略罗列并解释一下：</p>
<p>Predicates 预选策略是一组filter chain，所有node会经过file chain来层层过滤，最终筛选出合适的节点。</p>
<p><em>一般策略</em></p>
<table>
<thead>
<tr>
<th><strong>策略</strong></th>
<th><strong>描述</strong></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>PodFitsResources</td>
<td>用于判断当前node的资源是否满足pod的request的资源条件</td>
<td></td>
</tr>
<tr>
<td>PodFitsHost</td>
<td>用于判断当前node的名字是否满足pod所指定的nodeName</td>
<td></td>
</tr>
<tr>
<td>PodFitsHostPorts</td>
<td>Pod对象拥有spec.hostPort属性时,用于判断当前node可用的端口是否满足pod所要求的端口占用</td>
<td></td>
</tr>
<tr>
<td>PodMatchNodeSelector</td>
<td>用于判断当前node是否匹配pod所定义的nodeSelector或者nodeAffinity</td>
<td></td>
</tr>
</tbody>
</table>
<p><em>Volume相关策略</em></p>
<table>
<thead>
<tr>
<th><strong>策略</strong></th>
<th><strong>描述</strong></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>NoDiskConflict</td>
<td>用于判断多个pod所声明的volume是否有冲突，默认没有启用</td>
<td></td>
</tr>
<tr>
<td>MaxPDVolumeCountPredicate</td>
<td>用于判断某种volume是否已经超过所指定的数目</td>
<td></td>
</tr>
<tr>
<td>VolumeBindingPredicate</td>
<td>用于检查pod所定义的volume的nodeAffinity是否与node的标签所匹配</td>
<td></td>
</tr>
<tr>
<td>NoVolumeZoneConflict</td>
<td>检查给定的zone限制前提下，检查如果在此主机上部署Pod是否存在卷冲突</td>
<td></td>
</tr>
<tr>
<td>NoVolumeNodeConflict</td>
<td>检查给定的Node限制前提下，检查如果在此主机上部署Pod是否存在卷冲突</td>
<td></td>
</tr>
<tr>
<td>MaxEBSVolumeCount</td>
<td>确保已挂载的EBS存储卷不超过设置的最大值，默认39</td>
<td></td>
</tr>
<tr>
<td>MaxGCEPDVolumeCount</td>
<td>确保已挂载的GCE存储卷不超过设置的最大值，默认16</td>
<td></td>
</tr>
<tr>
<td>MaxAzureDiskVolumeCount</td>
<td>确保已挂载的Azure存储卷不超过设置的最大值，默认16</td>
<td></td>
</tr>
<tr>
<td>CheckVolumeBinding</td>
<td>检查节点上已绑定和未绑定的PVC是否满足需求</td>
<td></td>
</tr>
</tbody>
</table>
<p><em>Node相关策略</em></p>
<table>
<thead>
<tr>
<th><strong>策略</strong></th>
<th><strong>描述</strong></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>MatchNodeSelector</td>
<td>Pod对象拥有spec.nodeSelector属性时，检查Node节点的label定义是否满足Pod的NodeSelector属性需求</td>
<td></td>
</tr>
<tr>
<td>HostName</td>
<td>如果Pod对象拥有spec.hostname属性，则检查节点名称是不是Pod指定的NodeName</td>
<td></td>
</tr>
<tr>
<td>PodToleratesNodeTaints</td>
<td>Pod对象拥有spec.tolerations属性时，仅关注NoSchedule和NoExecute两个效用标识的污点</td>
<td></td>
</tr>
<tr>
<td>PodToleratesNodeNoExecuteTaints	P</td>
<td>od对象拥有spec.tolerations属性时，，是否能接纳节点的NoExecute类型污点,默认没有启用</td>
<td></td>
</tr>
<tr>
<td>CheckNodeLabelPresence</td>
<td>仅检查节点上指定的所有标签的存在性,默认没有启用</td>
<td></td>
</tr>
<tr>
<td>CheckServiceAffinity</td>
<td>将相同Service的Pod对象放置在同一个或同一类节点上以提高效率,默认没有启用</td>
<td></td>
</tr>
<tr>
<td>NodeMemoryPressurePredicate</td>
<td>检查当前node的内存是否充足，只有充足的时候才会调度到该node</td>
<td></td>
</tr>
<tr>
<td>CheckNodeMemoryPressure</td>
<td>检查节点内存压力，如果压力过大，那就不会将pod调度至此</td>
<td></td>
</tr>
<tr>
<td>CheckNodeDiskPressure</td>
<td>检查节点磁盘资源压力，如果压力过大，那就不会将pod调度至此</td>
<td></td>
</tr>
<tr>
<td>GeneralPredicates</td>
<td>检查pod与主机上kubernetes相关组件是否匹配</td>
<td></td>
</tr>
<tr>
<td>CheckNodeCondition</td>
<td>检查是否可以在节点报告磁盘、网络不可用或未准备好时将Pod调度其上</td>
<td></td>
</tr>
</tbody>
</table>
<p><em>Pod相关策略</em></p>
<table>
<thead>
<tr>
<th><strong>策略</strong></th>
<th><strong>描述</strong></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>PodAffinityPredicate</td>
<td>用于检查pod和该node上的pod是否和affinity以及anti-affinity规则匹配</td>
<td></td>
</tr>
<tr>
<td>MatchInterPodAffinity</td>
<td>检查节点是否满足Pod对象亲和性或反亲和性条件</td>
<td></td>
</tr>
</tbody>
</table>
<p>当然对于上面的规则链调用是有一定顺序的，通常跟node相关的规则会先计算，这样就可以避免一些没有必要的规则校验，比如在一个内存严重不足的node上面计算pod的affinity是没有意义的。有一个问题这么多调用链，如果待选择的node节点很多会不会
导致过滤很慢，过滤函数启动多个goroutine并行计算来对node进行过滤，所以过滤速度可以得到保证。</p>
<p>经过预选策略得到一组待选node后进入优选策略</p>
<p>kubernetes用一组优先级函数处理每一个待选的主机。每一个优先级函数会返回一个0-10的分数，分数越高表示主机越“好”，同时每一个函数也会对应一个表示权重的值。最终主机的得分用以下公式计算得出：</p>
<pre><code>finalScoreNode = (weight1 * priorityFunc1) + (weight2 * priorityFunc2) + … + (weightn * priorityFuncn)
</code></pre><p>Priorites策略也在随着版本演进而丰富，v1.0版本仅支持3个策略，v1.7支持10个策略，每项策略都有对应权重，最终根据权重计算节点总分。目前可用的Priorites策略有：</p>
<table>
<thead>
<tr>
<th><strong>策略</strong></th>
<th><strong>描述</strong></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>SelectorSpreadPriority</td>
<td>对于属于同一个service、replication controller的Pod，尽量分散在不同的主机上。如果指定了区域，则会尽量把Pod分散在不同区域的不同主机上。调度一个Pod的时候，先查找Pod对于的service或者replication controller，然后查找service或replication controller中已存在的Pod，主机上运行的已存在的Pod越少，主机的打分越高</td>
<td></td>
</tr>
<tr>
<td>LeastRequestedPriority</td>
<td>如果新的pod要分配给一个节点，这个节点的优先级就由节点空闲的那部分与总容量的比值（即（总容量-节点上pod的容量总和-新pod的容量）/总容量）来决定。CPU和memory权重相当，比值最大的节点的得分最高。需要注意的是，这个优先级函数起到了按照资源消耗来跨节点分配pods的作用。计算公式如下：cpu((capacity – sum(requested)) * 10 / capacity) + memory((capacity – sum(requested)) * 10 / capacity) / 2</td>
<td></td>
</tr>
<tr>
<td>BalancedResourceAllocation</td>
<td>尽量选择在部署Pod后各项资源更均衡的机器。BalancedResourceAllocation不能单独使用，而且必须和LeastRequestedPriority同时使用，它分别计算主机上的cpu和memory的比重，主机的分值由cpu比重和memory比重的“距离”决定。计算公式如下：10 – abs(totalCpu/cpuNodeCapacity-totalMemory/memoryNodeCapacity)*10</td>
<td></td>
</tr>
<tr>
<td>NodeAffinityPriority</td>
<td>节点亲和性选择策略。Node Selectors（调度时将pod限定在指定节点上），支持多种操作符（In, NotIn, Exists, DoesNotExist, Gt, Lt），而不限于对节点labels的精确匹配。另外，Kubernetes支持两种类型的选择器，一种是“hard（requiredDuringSchedulingIgnoredDuringExecution）”选择器，它保证所选的主机必须满足所有Pod对主机的规则要求。这种选择器更像是之前的nodeselector，在nodeselector的基础上增加了更合适的表现语法。另一种是“soft（preferresDuringSchedulingIgnoredDuringExecution）”选择器，它作为对调度器的提示，调度器会尽量但不保证满足NodeSelector的所有要求</td>
<td></td>
</tr>
<tr>
<td>InterPodAffinityPriority</td>
<td>pod亲和性选择策略,类似NodeAffinityPriority，提供两种选择器支持。有两个子策略podAffinity和podAntiAffinity</td>
<td></td>
</tr>
<tr>
<td>NodePreferAvoidPodsPriority(权重1W)</td>
<td>判断alpha.kubernetes.io/preferAvoidPods属性，设置权重为10000，覆盖其他策略</td>
<td></td>
</tr>
<tr>
<td>TaintTolerationPriority</td>
<td>使用Pod中tolerationList与Node节点Taint进行匹配，配对成功的项越多，则得分越低</td>
<td></td>
</tr>
<tr>
<td>ImageLocalityPriority</td>
<td>根据主机上是否已具备Pod运行的环境来打分，得分计算：不存在所需镜像，返回0分，存在镜像，镜像越大得分越高。默认没有启用</td>
<td></td>
</tr>
<tr>
<td>EqualPriority</td>
<td>EqualPriority是一个优先级函数，它给予所有节点相等的权重（优先级）</td>
<td></td>
</tr>
<tr>
<td>ServiceSpreadingPriority</td>
<td>按Service和Replicaset归属计算Node上分布最少的同类Pod数量，得分计算：数量越少得分越高（作用于SelectorSpreadPriority相同，已经被SelectorSpreadPriority替换）</td>
<td></td>
</tr>
<tr>
<td>MostRequestedPriority</td>
<td>在ClusterAutoscalerProvider中，替换LeastRequestedPriority，给使用多资源的节点，更高的优先级。计算公式为：(cpu(10 * sum(requested) / capacity) + memory(10 * sum(requested) / capacity)) / 2 动态伸缩集群环境比较适用，会优先调度pod到使用率最高的主机节点，这样在伸缩集群时，就会腾出空闲机器，从而进行停机处理。默认没有启用</td>
<td></td>
</tr>
</tbody>
</table>
<p>接下来会对scheduler 优选策略进行详细分析，请看 <a href="https://wukaiying.github.io/k8s/kube-scheduler-priority-source-read/">Kube Scheduler 优选策略源码分析</a></p>
<h3 id="heading-3">总结</h3>
<p>整个调度流程图可以用下面这幅图描述</p>
<p><img src="https://pic.images.ac.cn/image/5ea033588dfb4.html" alt="scheduler调度流程图"></p>
<ol>
<li>
<p>从待调度队列中取出一个pod，这块背后是由SchedulingQueue该模块实现，暂不进行深入分析</p>
</li>
<li>
<p>如果pod被标记为待删除，则不进行调度</p>
</li>
<li>
<p>加载调度策略，通过sched.schedule来对pod进行调度，如果调度成功会得到一个node节点名称（此时已经经过预选和优选完成）</p>
</li>
</ol>
<p>3.1 预选优选流程</p>
<ul>
<li>pod做一些前置过滤</li>
<li>获取node数量 numNodes := g.cache.NodeTree().NumNodes()</li>
<li>执行预选算法，得到可用的node filteredNodes。filteredNodes = g.findNodesThatFit(pluginContext, pod)</li>
<li>如果预选完成没有合适的node,如果只有一个Node,则直接返回该node</li>
<li>在优选函数中传入pod信息，和符合条件的node信息，进行优选</li>
<li>通过打分机制选择出最合适的node，host= g.selectHost(priorityList)，完成scheduler调度</li>
</ul>
<ol start="4">
<li>如果调度失败，查看返回的错误中，该pod是否启动了抢占策略，如果没有则什么也不做，当pod再次被更新需要重新调度时，pod重新入队，重新调度</li>
</ol>
<p>4.1 抢占流程</p>
<ul>
<li>pod做一些前置过滤</li>
<li>获取node数量 numNodes := g.cache.NodeTree().NumNodes()</li>
<li>执行预选算法，得到可用的node filteredNodes。filteredNodes = g.findNodesThatFit(pluginContext, pod)</li>
<li>如果预选完成没有合适的node,如果只有一个Node,则直接返回该node</li>
<li>在优选函数中传入pod信息，和符合条件的node信息，进行优选</li>
<li>通过打分机制选择出最合适的node，host= g.selectHost(priorityList)，完成scheduler调度</li>
</ul>
<ol start="5">
<li>
<p>执行绑定操作，也就是将pod.Spec.NodeName设置为选出来的node</p>
</li>
<li>
<p>得到最合适的node,将pod.spec.nodename设置为该值，提交到api server写入etcd,下一个组件Kubelet watch api server，完成pod创建</p>
</li>
</ol>
<p>具体方法调用链：</p>
<p>cmd/kube-scheduler/scheduler.go:32 NewSchedulerCommand()</p>
<pre><code>                ||
</code></pre>
<p>cmd/kube-scheduler/app/server.go:116 runCommand() runCommand方法主要作用是校验scheduler 配置参数，生成scheduler配置文件，并通过Run方法来启动scheduler</p>
<pre><code>                ||
</code></pre>
<p>cmd/kube-scheduler/app/server.go:165 Run()  启动scheduler</p>
<pre><code>                ||
</code></pre>
<p>pkg/scheduler/scheduler.go:315 sched.scheduleOne()  执行预选，优选，抢占，得到最合适的node,将pod.spec.nodename设置为该值，提交到api server写入etcd</p>
<h3 id="heading-4">后续</h3>
<p>很多公司结合自己业务，有需要扩展scheduler的需求，后续我会继续在一下两个方面研究：</p>
<p>1.scheduler 扩展实现自定义策略调度</p>
<p>2.scheduler GPU调度</p>
<p>扩展例子
example
<a href="https://github.com/everpeace/k8s-scheduler-extender-example">k8s-scheduler-extender-example</a></p>
<p>Gang Scheduling
<a href="https://github.com/kubernetes-sigs/kube-batch">Kube-batch</a>, gang scheduler 是某些领域，比如大数据、批量计算场景 常用的的调度方式，即讲一组资源当成一个 group，如果有 group 够用的资源就整个调度，或者整个不调度 (而传统的 kubernetes 的调度粒度为 pod). kubebatch 试图解决此类问题，并且想把这种通用的需求变成标准，解决所有类似的问题.</p>
<p><a href="https://github.com/AliyunContainerService/gpushare-scheduler-extender">gpushare-scheduler-extender</a>
为 gpu share divice 扩展的 scheduler，支持多个 pod 共享 gpu显存和 card. 目前的 device 机制能注册资源总量，但是对于调度来讲，信息不太够，因此 gpushare-scheduler-extender 提供了一层 filter 帮助判断 node 上是否有足够的 gpu 资源.</p>
<h3 id="heading-5">参考</h3>
<p><a href="https://kubernetes.io/zh/docs/reference/command-line-tools-reference/kube-scheduler/">https://kubernetes.io/zh/docs/reference/command-line-tools-reference/kube-scheduler/</a></p>
<p><a href="https://blog.tianfeiyu.com/source-code-reading-notes/kubernetes/kube_scheduler_algorithm.html">https://blog.tianfeiyu.com/source-code-reading-notes/kubernetes/kube_scheduler_algorithm.html</a></p>

    </article>

    


    <ul class="pager article-pager">
      <li class="pager-newer">
          <a href="/k8s/kubelet-structure/" data-toggle="tooltip" data-placement="top" title="Kubelet 架构分析">&lt; Newer</a>
      </li>
      <li class="pager-older">
        <a href="/k8s/replicaset-source-code-read/" data-toggle="tooltip" data-placement="top" title="Replica Set Controller 源码分析">Older &gt;</a>
      </li>
    </ul>
  </div>


<div class="site-footer">
  <div class="copyright">&copy; Copyright 2017 Your name</div>
  <ul class="site-footer-items">
    <li class="site-footer-item-about"><a href="/about/" title="About">About</a></li>
  </ul>
  <div class="powerdby">
    Powered by <a href="https://gohugo.io/">Hugo</a> and <a href="https://github.com/taikii/whiteplain">Whiteplain</a>
  </div>
</div>


</body>
</html>
